<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>React Popup Test</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
        .results {
            font-family: monospace;
            font-size: 14px;
            max-height: 400px;
            overflow-y: auto;
            white-space: pre-line;
        }
        .success { color: green; font-weight: bold; }
        .error { color: red; font-weight: bold; }
        .warning { color: orange; font-weight: bold; }
        .info { color: blue; }
        .debug { color: gray; }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useCallback } = React;

        function PopupTestApp() {
            const [logs, setLogs] = useState([]);
            const [performDetection, setPerformDetection] = useState(true);
            const [performSamePageRedirect, setPerformSamePageRedirect] = useState(false);
            const [isLoading, setIsLoading] = useState(false);
            
            // Match production state variables
            const [terminatingIncompleteClaimFlow, setTerminatingIncompleteClaimFlow] = useState(false);
            const [isRdcRedirecting, setIsRdcRedirecting] = useState(false);
            const [rdcInquiryId, setRdcInquiryId] = useState(null);
            const [rdcRedirectUrl, setRdcRedirectUrl] = useState(null);
            const [stepIndex, setStepIndex] = useState(1); // simulate being on RDC step

            const log = useCallback((msg, type = 'info') => {
                const time = new Date().toLocaleTimeString();
                setLogs(prevLogs => [...prevLogs, { time, msg, type }]);
            }, []);

            const clear = useCallback(() => {
                setLogs([]);
            }, []);

            // Simulate React re-renders and side effects like production
            useEffect(() => {
                if (terminatingIncompleteClaimFlow) {
                    // Simulate additional re-render work
                    setTimeout(() => {
                        setIsRdcRedirecting(true);
                    }, 0);
                }
            }, [terminatingIncompleteClaimFlow]);

            const detectPopupBlocker = useCallback(() => {
                let popup = null;
                let isBlocked = false;

                try {
                    const testName = `bluebidTest_${Math.random().toString(36).substr(2, 9)}`;
                    popup = window.open('', testName, 'width=1,height=1,left=-1000,top=-1000');
                    isBlocked = !popup || popup.closed || typeof popup.closed === 'undefined';
                } catch {
                    isBlocked = true;
                }

                if (popup && !popup.closed) {
                    try {
                        popup.close();
                    } catch (cleanupError) {
                        console.error('failed to cleanup popup during detection', cleanupError);
                    }
                }

                return isBlocked;
            }, []);

            const createRdcRedirectContext = useCallback((userAgent) => {
                // Simulate popupProtectionEnabledForUserAgent check (always true with .* pattern)
                const isPopupProtectionEnabledForUserAgent = true;
                
                // Only detect popup blocking if popup protection is enabled for this user agent
                const isPopupBlocked = isPopupProtectionEnabledForUserAgent
                    ? detectPopupBlocker()
                    : false;

                return {
                    isPopupProtectionEnabledForUserAgent,
                    isPopupBlocked,
                };
            }, [detectPopupBlocker]);

            // Match production detectPopupBlocking function signature
            const detectPopupBlocking = useCallback((params) => {
                const redirectContext = createRdcRedirectContext(params.userAgent);
                return redirectContext.isPopupBlocked;
            }, [createRdcRedirectContext]);

            const simulateRdcPopup = useCallback((popup = true) => {
                const form = document.createElement('form');
                form.method = 'POST';
                form.action = 'https://httpbin.org/post';
                form.target = popup ? '_blank' : '_self';
                form.style.display = 'none';
                document.body.appendChild(form);
                form.submit();
                document.body.removeChild(form);
            }, []);

            // Match production submitRdcForm
            const submitRdcForm = useCallback(async (params) => {
                const { url, popup } = params;
                log(`submitRdcForm called with popup=${popup}`, 'debug');
                
                if (!popup && !performSamePageRedirect) {
                    log('SKIPPING same-page redirect (checkbox unchecked) - would redirect to same page in production', 'warning');
                } else {
                    simulateRdcPopup(popup);
                }
            }, [simulateRdcPopup, performSamePageRedirect, log]);

            // Match production handleRdcRedirect
            const handleRdcRedirect = useCallback(async (params) => {
                const { redirectUrl, inquiryId, userAgent } = params;
                
                log('SECOND DETECTION: handleRdcRedirect() calling createRdcRedirectContext()...', 'info');
                const redirectContext = createRdcRedirectContext(userAgent);
                log(`Redirect Handler Result: ${redirectContext.isPopupBlocked ? 'BLOCKED' : 'ALLOWED'}`, redirectContext.isPopupBlocked ? 'error' : 'success');

                if (redirectContext.isPopupBlocked) {
                    log('Redirect Handler: Calling submitRdcForm({ popup: false }) - SAME-WINDOW REDIRECT', 'warning');
                    await submitRdcForm({ url: redirectUrl, popup: false });
                } else {
                    log('Redirect Handler: Calling submitRdcForm({ popup: true }) - POPUP REDIRECT', 'success');
                    await submitRdcForm({ url: redirectUrl, popup: true });
                }
            }, [createRdcRedirectContext, submitRdcForm, log]);

            // Match production onComplete callback
            const onComplete = useCallback(() => {
                const isRdcStep = stepIndex === 1; // simulate being on RDC step
                
                log('onComplete() called', 'debug');
                
                // handle RDC redirects (match production logic)
                if (rdcInquiryId && isRdcStep) {
                    if (rdcRedirectUrl) {
                        log('Calling handleRdcRedirect()...', 'info');
                        handleRdcRedirect({
                            redirectUrl: rdcRedirectUrl,
                            inquiryId: rdcInquiryId,
                            userAgent: navigator.userAgent,
                        });
                    } else {
                        log('ERROR: Missing redirect URL for RDC inquiry', 'error');
                    }
                    return;
                }
                
                log('Non-RDC flow completed', 'info');
            }, [stepIndex, rdcInquiryId, rdcRedirectUrl, handleRdcRedirect, log]);

            const apiCall = useCallback(async (delay) => {
                await fetch(`https://httpbin.org/delay/${delay}`, { method: 'POST' });
            }, []);

            // Match production button onClick structure
            const simulateButtonClick = useCallback(async () => {
                clear();
                setIsLoading(true);
                log('User clicked "Get Started" button', 'info');
                
                // Simulate having RDC inquiry data (like production sets these)
                setRdcInquiryId('test-inquiry-id');
                setRdcRedirectUrl('https://httpbin.org/post');

                log('React: setTerminatingIncompleteClaimFlow(true)', 'debug');
                setTerminatingIncompleteClaimFlow(true);
                await new Promise(resolve => setTimeout(resolve, 0));

                log('React: setIsRdcRedirecting(true)', 'debug');
                setIsRdcRedirecting(true);
                await new Promise(resolve => setTimeout(resolve, 0));

                log('API: await terminateIncompleteClaimFlow()', 'debug');
                await apiCall(0.1);

                log('API: await verifyRdcRedirectAllowed()', 'debug');
                await apiCall(0.15);

                // FIRST DETECTION: In button handler (like production)
                if (performDetection) {
                    log('FIRST DETECTION: Button handler calling detectPopupBlocking()...', 'info');
                    const needsPopupProtection = detectPopupBlocking({ userAgent: navigator.userAgent });
                    log(`Button Handler Result: ${needsPopupProtection ? 'BLOCKED' : 'ALLOWED'}`, needsPopupProtection ? 'error' : 'success');

                    if (needsPopupProtection) {
                        log('Button Handler: Will await queueRdcInquiry', 'debug');
                    } else {
                        log('Button Handler: Will fire-and-forget queueRdcInquiry ("RDC popup protection not needed")', 'debug');
                    }
                } else {
                    log('Skipping first popup detection', 'warning');
                }

                // Call onComplete like production does
                log('Calling onComplete()...', 'info');
                onComplete();
                
                log('Test complete.', 'info');

                setIsLoading(false);
                setTerminatingIncompleteClaimFlow(false);
                setIsRdcRedirecting(false);
            }, [performDetection, log, clear, apiCall, detectPopupBlocking, onComplete]);

            return (
                <div className="container mt-4">
                    <h1 className="mb-4">React Popup Simulation</h1>
                    
                    <div className="card mb-4">
                        <div className="card-body">
                            <h3 className="card-title">Current Production Method (React)</h3>
                            <p><em>Uses React state management and `window.open` to test popup blocking.</em></p>
                            <hr />
                            <div className="form-check mb-3">
                                <input 
                                    className="form-check-input" 
                                    type="checkbox" 
                                    id="performDetection" 
                                    checked={performDetection}
                                    onChange={(e) => setPerformDetection(e.target.checked)}
                                />
                                <label className="form-check-label" htmlFor="performDetection">
                                    Perform popup detection check
                                </label>
                            </div>
                            <div className="form-check mb-3">
                                <input 
                                    className="form-check-input" 
                                    type="checkbox" 
                                    id="performSamePageRedirect" 
                                    checked={performSamePageRedirect}
                                    onChange={(e) => setPerformSamePageRedirect(e.target.checked)}
                                />
                                <label className="form-check-label" htmlFor="performSamePageRedirect">
                                    Perform redirect on same-page redirect
                                </label>
                            </div>
                            <div className="d-flex gap-2 align-items-center mb-3">
                                <button 
                                    className="btn btn-primary btn-lg" 
                                    onClick={simulateButtonClick}
                                    disabled={isLoading}
                                >
                                    {isLoading ? 'Running...' : 'Simulate "Get Started" Click'}
                                </button>
                            </div>
                            <div className="results border p-3 bg-light rounded">
                                {logs.map((log, index) => (
                                    <div key={index}>
                                        <span className={log.type}>[{log.time}] {log.msg}</span>
                                    </div>
                                ))}
                            </div>
                        </div>
                    </div>
                </div>
            );
        }

        ReactDOM.render(<PopupTestApp />, document.getElementById('root'));
    </script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
</body>
</html> 